<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>배열</title>
   <style>
      .area {
         width: 400px;
         border: 1px solid;
         padding: 5px;
      }
   </style>
</head>
<body>
   <h1>배열</h1>
   <p>
      - 변수 선언시 별도의 자료형 지정하지 않음<br>
      - 어떤 자료형의 값들이든 다 하나의 배열 공간에 담을 수 있음<br>
      - 크기의 제약이 없음(선언시 크기를 지정하지 않아도됨)<br>
      - 존재하지 않는 인덱스를 참조해도 오류가 나지 않음(undefined를 리턴)
   </p>

   <button onclick="arrayTest1();">확인하기</button>
   <div id="area1" class="area"></div>

   <script>
      function arrayTest1() {
         const arr = ['홍길동', 20, true, ['홍길동', 20, true]];
      
         console.log(arr); // ['홍길동', 20, true, ['홍길동', 20, true]]
         console.log(arr[2]); // true
         console.log(arr[3]); // ['홍길동', 20, true]
         console.log(arr[4]); // undefined
         console.log(arr[3][1]); // 20
         
         const area1 = document.getElementById("area1");

         // for(let i=0; i<arr.length; i++) {
         //    area1.innerHTML += arr[i] + "<br>"; // = area1.innerHTML += `${arr[i]}<br>`;
         // }

         // 향상된 for문(배열일 경우 사용 가능) 
         for(let i in arr) { // 변수(index번호) in 배열
            area1.innerHTML += `${arr[i]}<br>`;
         }
      }
   </script>

   <h3>* 배열의 선언</h3>
   <button onclick="arrayTest2();">확인하기</button>
   <script>
      function arrayTest2() {
         const arr1 = new Array();
         const arr2 = new Array(3);
         const arr3 = [];

         console.log(arr1);
         console.log(arr2);
         console.log(arr3);

         // 배열에 값 넣기
         arr1[0] = "바나나";
         arr1[1] = "사과";
         arr1[2] = "키위";
         console.log('-----------------------');
         console.log(arr1)

         arr2[0] = "제트기";
         arr2[1] = "기차";
         arr2[2] = "오토바이";
         arr2[3] = "자동차"
         console.log('-----------------------');
         console.log(arr2) // 3개라 크기를 줬지만 상관없이 값을 추가적으로 넣을 수 있다

         // 배열 선언과 동시에 초기화(new Array 생략 가능)
         const arr4 = ['java', 'oracle', 'jsp']; // new Array 생략 가능
         const arr5 = new Array('java', "oracle", `jsp`); // 백틱도 가능

         console.log(arr4);
         console.log(arr5);
      }
   </script>

   <hr>

   <h3>* 배열 관련 메소드</h3>
   <h4>1) 배열.indexOf(찾고자하는 요소)</h4>
   <p>배열에서 해당 요소가 위치해 있는 인덱스를 반환</p>
   <div id="area2" class="area"></div>
   <button onclick="indexOfTest();">확인하기</button>

   <script>
      function indexOfTest() {
         const area2 = document.getElementById("area2");
         const arr = ['사과', "딸기", `포도`, '귤', "복숭아"];
         const fruit = prompt("좋아하는 과일이 무엇이냐");

         const index = arr.indexOf(fruit);
         console.log(index);

         area2.innerHTML = `당신이 찾는 과일 '${fruit}'는 `;
         if(index != -1) {
            area2.innerHTML +=  index + "번 인덱스에 있습니다";
         } else {
            area2.innerHTML += '판매하지 않습니다';
         } 

         // 자바스크립트 동등 비교   
         // '=' 2개는 값만 비교(동등비교: 연산자 자료형과 무관하게 실제값만 일치해도 true)
         console.log(1 == 1); // true
         console.log(1 == '1'); // true 

         // '=' 3개는 값이랑 자료형 둘 다 비교(엄격비교: 값과 자료형 둘 다 일치해야 true)
         console.log(1 === 1); // true
         console.log(1 === '1'); // false
         }
   </script>

   <hr>

   <h4>2) 배열.concat(배열, 배열, ...)</h4>
   <p>배열 여러개를 결합하고자할 때 사용</p>
   <div id="area3" class="area"></div>
   <button onclick="concatTest();">확인하기</button>

   <script>
      function concatTest() {
         const area3 = document.getElementById('area3');

         const arr1 = ['사과', "딸기", `포도`, '귤', "복숭아"];
         const arr2 = ['자동차', `기차`, "오토바이"];

         area3.innerHTML = "arr1: " + arr1 + "<br>";
         area3.innerHTML += `arr2: ` + arr2 +`<br>`;
         area3.innerHTML += arr1 + '/' + arr2 + '<br><br>'

         arr3 = arr1.concat(arr2);
         area3.innerHTML += "arr1을 기준으로 배열 합침: <br>" + arr3 + '<br><br>';

         // 원본에 영향을 끼치지않음
         area3.innerHTML += "arr1 원본은 그대로 " + arr1 + "<br><br>";

         arr4 = arr2.concat(arr1);
         area3.innerHTML += "arr2을 기준으로 배열 합침: <br>" + arr4 + '<br>';
      }
   </script>

   <hr>

   <h4>3) 배열.reverse()</h4>
   <p>배열에 담긴 값들을 역순으로 바꿔주는 함수</p>
   <div id="area4" class="area"></div>
   <button onclick="reverseTest();">확인하기</button>

   <script>
      function reverseTest() {
         const area4 = document.getElementById("area4");
         const arr = ['1', "2", `3`, '4', "5"];

         area4.innerHTML += `arr: ${arr}<br>`;
         area4.innerHTML += `reverse결과: ${arr.reverse()}<br>`;

         // 원본에 영향을 끼침
         area4.innerHTML += `arr 원본: ${arr}<br>`;

      }
   </script>

   <hr>

   <h4>4) 배열.sort()</h4>
   <p>배열에 담긴 값들을 정렬시켜주는 함수</p>
   <div id="area5" class="area"></div>
   <button onclick="sortTest();">확인하기</button>

   <script>
      function sortTest() {
         const area5 = document.getElementById(`area5`);
   
         const arr = [7, 3, 9, 4, 0, 5, 1];
         const name = ['홍길동', '김길동', '박길동', '나길동', '이길동'];

         area5.innerHTML = `arr: ${arr}<br>`;
         area5.innerHTML += `name: ${name}<br><br>`;

         // 오름차순(기본값)
         area5.innerHTML += `arr: ${arr.sort()}<br>`;
         area5.innerHTML += `name: ${name.sort()}<br><br>`;

         // 내림차순
         area5.innerHTML += `arr: ${arr.sort().reverse()}<br>`;
         area5.innerHTML += `name: ${name.sort().reverse()}<br><br>`;

         // 원본에 영향을 끼침
         area5.innerHTML += `arr 원본: ${arr}<br>`;
         area5.innerHTML += `name 원본: ${name}<br><br>`;
      }
   </script>

   <hr>

   <h4>5) 배열.push(추가할 요소), 배열.pop()</h4>
   <p>5.1) 배열.push(추가할 요소): 배열의 맨 뒤에 요소를 추가하고 배열의 크기 반환<br>
      5.2) 배열.pop(): 배열의 맨 뒤 요소를 제거하고 제거된 요소 반환
   </p>
   <div id="area6" class="area"></div>
   <button onclick="pushPopTest();">확인하기</button>

   <script>
      function pushPopTest() {
         const area6 = document.getElementById('area6');
         const str = ['가산동', '서초동', '방배동', '역삼동', '삼성동'];

         area6.innerHTML = `str: ${str}<br>`;
         area6.innerHTML += `push 한 후 str 요소의 갯수: ${str.push('신도림동')}<br>`;
         area6.innerHTML += `push 한 후 str: ${str}<br><br>`;
         area6.innerHTML += `pop하면 제거되는 요소: ${str.pop()}<br>`;
         area6.innerHTML += `pop 한 후 str: ${str}<br><br>`;

         str.pop();
         str.pop();
         str.pop();
         str.pop();
         area6.innerHTML += `최종 str: ${str}<br><br>`;

      }
   </script>

   <hr>

   <h4>6) 배열.unshift(추가할 요소), 배열.shift</h4>
   <p>6.1) 배열.push(추가할 요소): 배열의 맨 앞에 요소를 추가하고 배열의 크기 반환<br>
      6.2) 배열.shift(): 배열의 맨 앞 요소를 제거하고 제거된 요소 반환
   </p>
   <div id="area7" class="area"></div>
   <button onclick="unShiftTest();">확인하기</button>

   <script>
      function unShiftTest() {
         const area7 = document.querySelector(`#area7`);
         const arr = ['야구', '농구', '배구', '볼링'];

         area7.innerHTML = "arr: " + arr + "<br><br>";
         area7.innerHTML += 'unshift한 후 arr 요소의 갯수: ' + arr.unshift("테니스") + '<br>';
         area7.innerHTML += `unshift 한 후 arr: ${arr} <br><br>`;
         area7.innerHTML += `shift하면 제거되는 요소: ${arr.shift()}<br>`;
         area7.innerHTML += `shift 한 후 arr: ${arr}<br><br>`;
      }
   </script>

   <hr>

   <h4>7) 배열.slice(시작인덱스, 끝인덱스), 배열.splice(시작인덱스, 제거수[, 추가할 값])</h4>
   <p>7.1) 배열.slice(시작인덱스, 끝인덱스): 배열로부터 시작인덱스에서부터 끝인덱스까지 추출해주는 함수<br>
      7.2) 배열.splice(시작인덱스, 제거수[, 추가할 값]): 배열의 요소 추출해서 제거 및 추가
   </p>
   <div id="area8" class="area"></div>
   <button onclick="sliceSpliceTest();">확인하기</button>

   <script>
      function sliceSpliceTest() {
         const area8 = document.querySelector("#area8");
         const arr = ['java', 'jsp', 'html5', 'css3', 'javascript'];

         area8.innerHTML = `arr: ${arr}<br>`;
         area8.innerHTML += `slice 결과: ${arr.slice(1, 4)}<br>`; // 1번부터 3번까지
         area8.innerHTML += `slice 결과: ${arr.slice(2)}<br><br>`; // 2번부터 끝까지
         // 원본에 영향을 끼치지 않음
         area8.innerHTML += `slice한 후 arr 원본: ${arr}<br><br>`;

      //   area8.innerHTML += `splice 결과: ${arr.splice(2, 2)}<br><br>`; // 2번부터 2개를 추출 후 제거
         area8.innerHTML += `splice 결과: ${arr.splice(2, 2, 'spring', 'oracle')}<br><br>`; // 2번부터 2개를 추출 후 제거하고 'spring', oracle 추가
      
      // 원본에 영향을 끼침
         area8.innerHTML += `splice한 후 arr 원본: ${arr}<br><br>`;
      }
   </script>

   <hr>

   <h4>8) 배열.toString(), 배열.join([구분자])</h4>
   <p>배열에 각 인덱스에 담긴 값들을 하나의 문자열로 합쳐서 반환
   </p>
   <div id="area9" class="area"></div>
   <button onclick="toStringJoinTest();">확인하기</button>

   <script>
      function toStringJoinTest() {
         const area9 = document.querySelector('#area9');
         const arr = ['java', 'jsp', 'html5', 'css3', 'javascript'];

         area9.innerHTML = `arr: ${arr}<br>`;
         area9.innerHTML += `toString 결과: ${arr.toString()}<br><br>`;

         area9.innerHTML += `join 결과: ${arr.join()}<br>`; // 구분자 default값 콤마(,)를 넣어 연결
         area9.innerHTML += `구분자를 넣은 join 결과: ${arr.join(' ')}<br>`; // 콤마가 아닌 ' '로 구분지음
         area9.innerHTML += `구분자를 넣은 join 결과: ${arr.join('/')}<br>`; // 콤마가 아닌 '/'로 구분지음
      }
   </script>
   
   <hr>

   <h4>9) 반복처리</h4>
   
   <div id="area10" class="area"></div>
   <button onclick="forTest();">확인하기</button>

   <script>
      function forTest() {
         const area10 = document.querySelector('#area10');
         const arr = ['가', '나', '다', '라'];

         area10.innerHTML = `for: `;
         for(let i=0; i<arr.length; i++) {
            if (i==arr.length-1) // 마지막 인덱스에 '/'를 안넣는 구문
               area10.innerHTML += `${arr[i]}`;
            else
               area10.innerHTML += `${arr[i]}/`;
         }

         area10.innerHTML += '<br>';

         // 배열에 인덱스 속성 가져오기
         area10.innerHTML += "for in: ";
         for(let i in arr) {
            if (i==arr.length-1)
               area10.innerHTML += `${i} = ${arr[i]}<br>`;
            else
               area10.innerHTML += `${i} = ${arr[i]}, `;
         }
         
         // 배열에 요소 가져오기
         area10.innerHTML += "for of: ";
         for(let ch of arr) {
               area10.innerHTML += `${ch}`;
         }
         area10.innerHTML += '<br>';

         // 각 요소별로 전달한 함수(콜백함수) 실행
         area10.innerHTML += "for each: <br>";
         arr.forEach(function(elem, index, arr){ // 요소, [인덱스], [배열] (순서 바뀌면 안됨)
                                                  // e, i, a 이렇게 입력하든 맘대로 변수명을 지정하면 된다

            area10.innerHTML += ` ${index} = ${elem}, arr = ${arr}<br>`;
         });

      }
   </script>
   
   <hr>

   <h4>10) map: 배열의 각 요소별 작업 후 새 요소를 담은 배열 반환<br>
       11) filter: 각 요소별 콜백함수를 실행하여 true인 요소만 새 배열에 담아서 반환<br>
       12) reduce: 모든 요소를 대상으로 특정 작업 후 하나의 값(객체)로 반환<br>
            - 최대/최소값, 누적합 등의 작업에 적합<br>
            - reduce(콜백함수, 초기값): 초기값을 생략하면 배열의 첫번째 요소가 초기값이 된다<br>
   </h4>

   <div id="area11" class="area">
      <ul></ul>
   </div>
   <button onclick="mapTest();">map 확인하기</button>&emsp;
   <button onclick="filterTest();">filter 확인하기</button>&emsp;
   <button onclick="reduceTest();">reduce 확인하기</button>&emsp;

   <script>
      const area11 = document.querySelector("#area11>ul");
      function mapTest() {
         // [1, 2, 3]; -> [1, 4, 9];
         const arr = [1, 2, 3];
         const arr2 = arr.map(function(value, index, arr){
            // console.log(value, index, arr)
            return value*value;
         });
         console.log(arr);
         console.log(arr2); 
       
         const names = ['강남길', '황정음', '유재석'];
         // for(let i=0; i<names.length; i++) {
         //    area11.innerHTML += `<li>${names[i]}</li>`;
         // }

         // for(let i in names) {
         //    area11.innerHTML += `<li>${names[i]}</li>`;
         // }

         // for(let i of names) {
         //    area11.innerHTML += `<li>${[i]}</li>`;
         // }

         const nameList = names.map(function(name){
            return `<li>${name}</li>`;
         });
         console.log(nameList); // '<li>강남길</li>', '<li>황정음</li>', '<li>유재석</li>'

         // nameList.forEach(function(value) {
         //    area11.innerHTML += value;
         // });

         for(let i in nameList) {
            area11.innerHTML += nameList[i];
         }

         for(let i of nameList) {
            area11.innerHTML += [i];
         }

         // for(let i=0; i<nameList.length; i++) {
         //    area11.innerHTML += nameList[i];
         // }
      }
      function filterTest() {
         const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

         const evens = nums.filter(function(value, index, arr){
            return value % 2 == 0;
         });

         area11.innerHTML = `짝수만 추출: ${evens}<br>`;

         const arr = [];
         for(let i=0; i<100; i++) {
            arr.push(i+1);
         }

         const result = arr.filter(function(value){
           return value <= 30 && value % 3 == 0;
         });
         area11.innerHTML += `30이하 숫자 중 3의 배수: ${result}<br>`;

      }
      function reduceTest() {
         const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

         const sum = nums.reduce(function(pv, cv){ // 변수값(sum), 현재요소, [인덱스], [배열]
            return pv + cv;
         });

         console.log(sum);
         area11.innerHTML += `1~10까지 합 = ${sum}<br>`;
         // for문으로 바꾸면
         // let sum1 = 0;
         // for(let i=0; i<=10; i++){sum1 += i;}

         const arr = [5, 3, 8, 2, 4, 9, 6, 1, 7];
         const max = arr.reduce(function(pv, cv){
            return pv > cv ? pv : cv;
         });
         console.log(max);
         area11.innerHTML += `제일 큰 값 = ${max}<br>`;

         const min = arr.reduce(function(pv, cv){
            return pv > cv ? cv : pv;
         });
         console.log(min);
         area11.innerHTML += `제일 작은 값 = ${min}<br>`;
      }
   </script>

   
  



  <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>